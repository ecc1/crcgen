package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
)

var prog = os.Args[0]
var goFile = os.Getenv("GOFILE")
var goPackage = os.Getenv("GOPACKAGE")

func main() {
	if goFile == "" || goPackage == "" {
		log.Fatalf("%s must be run via \"go:generate\" or have GOFILE and GOPACKAGE set", prog)
	}
	kind := goFile[0 : len(goFile)-len(filepath.Ext(goFile))]
	switch kind {
	case "crc8":
		gen_crc8(setup(kind), 0x9B) // WCDMA polynomial
	case "crc16":
		gen_crc16(setup(kind), 0x1021) // CCITT polynomial
	default:
		log.Fatal("GOFILE environment variable must be \"crc8\" or \"crc16\"")
	}
}

func setup(kind string) *os.File {
	f, err := os.Create(fmt.Sprintf("%s_table.go", kind))
	if err != nil {
		log.Fatal(err)
	}
	fmt.Fprintf(f, "// Generated by gen_crc_table: do not edit\n\n")
	fmt.Fprintf(f, "package %s\n\n", goPackage)
	return f
}

// Generate lookup table for CRC-8 calculation
func gen_crc8(f *os.File, poly uint8) {
	fmt.Fprintf(f, "// Lookup table for CRC-8 calculation with polyomial 0x%02X\n", poly)
	fmt.Fprintf(f, "var crc8Table = []uint8{\n")
	for i := 0; i < 256; i++ {
		res := uint8(i)
		for n := 0; n < 8; n++ {
			c := res & (1 << 7)
			res <<= 1
			if c != 0 {
				res ^= poly
			}
		}
		if i%8 == 0 {
			fmt.Fprintf(f, "\t")
		} else {
			fmt.Fprintf(f, " ")
		}
		fmt.Fprintf(f, "0x%02X,", res)
		if (i+1)%8 == 0 {
			fmt.Fprintf(f, "\n")
		}
	}
	fmt.Fprintf(f, "}\n")
	f.Close()
}

// Generate lookup table for CRC-16 calculation
func gen_crc16(f *os.File, poly uint16) {
	fmt.Fprintf(f, "// Lookup table for CRC-16 calculation with polynomial 0x%04X\n", poly)
	fmt.Fprintf(f, "var crc16Table = []uint16{\n")
	for i := 0; i < 256; i++ {
		res := uint16(0)
		b := uint16(i << 8)
		for n := 0; n < 8; n++ {
			c := (res ^ b) & (1 << 15)
			res <<= 1
			b <<= 1
			if c != 0 {
				res ^= poly
			}
		}
		if i%8 == 0 {
			fmt.Fprintf(f, "\t")
		} else {
			fmt.Fprintf(f, " ")
		}
		fmt.Fprintf(f, "0x%04X,", res)
		if (i+1)%8 == 0 {
			fmt.Fprintf(f, "\n")
		}
	}
	fmt.Fprintf(f, "}\n")
	f.Close()
}
